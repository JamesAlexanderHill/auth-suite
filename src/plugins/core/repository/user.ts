import { StoreError } from "../../../utils/error";
import type { TBaseUser } from "../types";

export interface IUserRepository<TUser extends TBaseUser = TBaseUser> {
  /**
   * Gets a user by their ID.
   *
   * @param id - User's id.
   * @returns The user associated with the id or null if no user exists.
   */
  getById(id: string): Promise<Readonly<TUser> | null>;

  /**
   * Gets a user by their email.
   *
   * @param email - User's email.
   * @returns The user associated with the email or null if no user exists.
   */
  getByEmail(email: string): Promise<Readonly<TUser> | null>;

  /**
   * Create a new user.
   *
   * @param user - User data without `id` (it is generated by the store).
   * @returns The newly created user, including assigned `id`.
   * @throws StoreError('unique-violation') if email already exists.
   */
  create(user: Omit<TUser, "id">): Promise<Readonly<TUser>>;

  /**
   * Update an existing user.
   *
   * @param id - ID of the user to update.
   * @param user - Partial set of fields to update (cannot change `id`).
   * @returns The updated user.
   * @throws StoreError('entry-not-found') if no user exists with this ID.
   */
  update(
    id: string,
    user: Partial<Omit<TUser, "id">>
  ): Promise<Readonly<TUser>>;

  /**
   * Delete a user.
   *
   * @param id - ID of the user to delete.
   * @returns Resolves when deletion succeeds.
   * @throws StoreError('entry-not-found') if no user exists with this ID.
   */
  delete(id: string): Promise<void>;

  /**
   * List users with offset-based pagination.
   *
   * @param limit - Maximum number of users to return.
   * @param offset - Number of users to skip before returning results.
   * @param sortBy - Key to sort users
   * @param sortDir - 'asc' or 'desc'
   * @throws StoreError('invalid-input') if pagination values are invalid.
   * @returns A list of users
   */
  list(
    limit: number,
    offset: number,
    sortBy?: keyof TUser,
    sortDir?: "asc" | "desc"
  ): Promise<{
    items: Readonly<TUser>[];
    meta: {
      /** Number of items on the current page */
      count: number;
      /** Page offset index */
      offset: number;
      /** Total number of items */
      total?: number;
    };
  }>;
}

// memory util functions
type Mutable<T> = { -readonly [K in keyof T]: T[K] };

function shallowFreeze<T>(obj: T): Readonly<T> {
  return Object.freeze({ ...obj }) as Readonly<T>;
}

const collator = new Intl.Collator(undefined, {
  numeric: true,
  sensitivity: "base",
});

function compareValues(a: unknown, b: unknown): number {
  if (a == null && b == null) return 0;
  if (a == null) return -1; // or flip if you want nulls last
  if (b == null) return 1;

  if (typeof a === "number" && typeof b === "number") {
    if (Number.isNaN(a) && Number.isNaN(b)) return 0;
    if (Number.isNaN(a)) return -1;
    if (Number.isNaN(b)) return 1;
    return a - b;
  }
  if (a instanceof Date && b instanceof Date) return a.valueOf() - b.valueOf();

  return collator.compare(String(a), String(b));
}
const normalizeEmail = (email: string) => email.trim().toLowerCase();

export class MemoryUserRepository<TUser extends TBaseUser = TBaseUser>
  implements IUserRepository<TUser>
{
  /** Primary store by id */
  private store: Map<string, TUser>;
  /** Secondary unique index: normalized email -> id */
  private emailIndex = new Map<string, string>();

  private generateId: () => string;

  constructor({
    initialUsers = new Map<string, TUser>(),
    generateId = () => crypto.randomUUID() as string,
  } = {}) {
    this.store = new Map(initialUsers);
    this.generateId = generateId;

    Array.from(this.store).forEach(([id, user]) => {
      const normEmail = normalizeEmail(user.email);

      if (this.emailIndex.has(normEmail)) {
        throw new StoreError(
          "unique-violation",
          `Email already exists: ${user.email}`
        );
      }

      this.emailIndex.set(normEmail, id);
    });
  }

  async getById(id: string): Promise<Readonly<TUser> | null> {
    const found = this.store.get(id);
    return found ? shallowFreeze(found) : null;
  }

  async getByEmail(email: string): Promise<Readonly<TUser> | null> {
    const norm = normalizeEmail(email);
    const id = this.emailIndex.get(norm);
    if (!id) return null;
    const user = this.store.get(id);
    return user ? shallowFreeze(user) : null;
  }

  async create(input: Omit<TUser, "id">): Promise<Readonly<TUser>> {
    const normEmail = normalizeEmail(input.email);
    if (this.emailIndex.has(normEmail)) {
      throw new StoreError(
        "unique-violation",
        `Email already exists: ${input.email}`
      );
    }

    // Construct user with generated id; keep other fields as provided.
    const user = {
      ...(input as Mutable<TUser>),
      id: this.generateId(),
    } as TUser;

    this.store.set(user.id, user);
    this.emailIndex.set(normEmail, user.id);

    return shallowFreeze(user);
  }

  async update(
    id: string,
    patch: Partial<Omit<TUser, "id">>
  ): Promise<Readonly<TUser>> {
    const existing = this.store.get(id);
    if (!existing)
      throw new StoreError("entry-not-found", `User not found: ${id}`);

    // Pre-validate email change
    let nextEmailIndexKey: string | undefined;
    if (patch.email !== undefined) {
      const newNorm = normalizeEmail(patch.email);
      const currentNorm = normalizeEmail(existing.email);
      if (newNorm !== currentNorm) {
        const clashId = this.emailIndex.get(newNorm);
        if (clashId && clashId !== id) {
          throw new StoreError(
            "unique-violation",
            `Email already exists: ${patch.email}`
          );
        }
        nextEmailIndexKey = newNorm;
      }
    }

    // Persist record first
    const updated: TUser = {
      ...(existing as Mutable<TUser>),
      ...(patch as any),
      id,
    };
    this.store.set(id, updated);

    // Now update the secondary index
    if (nextEmailIndexKey) {
      this.emailIndex.delete(normalizeEmail(existing.email));
      this.emailIndex.set(nextEmailIndexKey, id);
    } else if (patch.email !== undefined) {
      // email set but normalized equal â€” ensure index consistency
      this.emailIndex.set(normalizeEmail(updated.email), id);
    }

    return shallowFreeze(updated);
  }

  async delete(id: string): Promise<void> {
    const existing = this.store.get(id);
    if (!existing) {
      throw new StoreError("entry-not-found", `User not found: ${id}`);
    }
    this.store.delete(id);
    this.emailIndex.delete(normalizeEmail(existing.email));
  }

  async list(
    limit: number,
    offset: number,
    sortBy: keyof TUser = "id",
    sortDir: "asc" | "desc" = "asc"
  ): Promise<{
    items: Readonly<TUser>[];
    meta: { count: number; offset: number; total?: number };
  }> {
    if (limit < 0 || offset < 0) {
      throw new StoreError("invalid-input", "limit/offset must be >= 0");
    }

    const total = this.store.size;

    // Materialize to array
    const rows = Array.from(this.store.values());

    // Stable sort by key, then id as tiebreaker
    rows.sort((a, b) => {
      const dir = sortDir === "asc" ? 1 : -1;
      const primary = compareValues(a[sortBy], b[sortBy]);
      if (primary !== 0) return dir * primary;
      return dir * compareValues(a.id, b.id);
    });

    const page = rows.slice(offset, offset + limit);
    const items = page.map(shallowFreeze);

    return {
      items,
      meta: {
        count: items.length,
        offset,
        total, // cheap for in-memory; keep optional to match your contract
      },
    };
  }
}
