import type { TBaseOtp } from "../types";

export interface IOtpRepository<TOtp extends TBaseOtp = TBaseOtp> {
  /**
   * Gets an OTP by its ID.
   *
   * @param id - OTP's id.
   * @returns The OTP associated with the id or null if no OTP exists.
   */
  getById(id: string): Promise<Readonly<TOtp> | null>;

  /**
   * Create a new OTP.
   *
   * @param otp - OTP data without `id` (it is generated by the store).
   * @returns The newly created OTP, including assigned `id`.
   * @throws StoreError('unique-violation') if ID already exists.
   */
  create(otp: Omit<TOtp, "id">): Promise<Readonly<TOtp>>;

  /**
   * Update an existing OTP.
   *
   * @param id - ID of the OTP to update.
   * @param otp - Partial set of fields to update (cannot change `id`).
   * @returns The updated OTP.
   * @throws StoreError('entry-not-found') if no OTP exists with this ID.
   */
  update(id: string, user: Partial<Omit<TOtp, "id">>): Promise<Readonly<TOtp>>;

  /**
   * Delete an OTP.
   *
   * @param id - ID of the OTP to delete.
   * @returns Resolves when deletion succeeds.
   * @throws StoreError('entry-not-found') if no OTP exists with this ID.
   */
  delete(id: string): Promise<void>;

  /**
   * List OTP with offset-based pagination.
   *
   * @param limit - Maximum number of records to return.
   * @param offset - Number of records to skip before returning results.
   * @param sortBy - Key to sort records
   * @param sortDir - 'asc' or 'desc'
   * @throws StoreError('invalid-input') if pagination values are invalid.
   * @returns A list of OTP's
   */
  list(
    limit: number,
    offset: number,
    sortBy?: keyof TOtp,
    sortDir?: "asc" | "desc"
  ): Promise<{
    items: Readonly<TOtp>[];
    meta: {
      /** Number of items on the current page */
      count: number;
      /** Page offset index */
      offset: number;
      /** Total number of items */
      total?: number;
    };
  }>;
}

export class MemoryOtpRepository<TOtp extends TBaseOtp = TBaseOtp>
  implements IOtpRepository<TOtp>
{
  /** Primary store by id */
  private store: Map<string, TOtp>;
}
